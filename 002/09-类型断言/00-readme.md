# 类型断言

类型断言可以用来手动指定一个值的类型

## 语法
```
值 as 类型
```

或
```
<类型>值
```

在tsx语法(react 的jsx语法的ts版)中必须使用前者，即as类型

形如<Foo>的语法在tsx中表示的是一个ReactNode 在ts中除了表示类型断言之外，也可能表示一个泛型  
所以建议在使用类型断言是，使用 值as 类型 这样的语法

## 类型断言的用途

### 1. 将一个联合类型断言为其中一个类型

联合类型中提到过，当typescript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的多有类型中共有的属性或方法;

[demo01][demo01]

而有时候我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法

[demo02][demo02]

上面的例子中获取animal.swim 的时候会报错。

此时可以使用类型断言，将animal 断言成 Fish  
[demo03][demo03]

需要注意的是类型断言只能够【欺骗】Typescript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误  
[demo04][demo04]

### 2.  将一个父类断言为一个更加具体的子类
[demo05][demo05]

上面的例子使用instenceof 更加合适  
[demo06][demo06]

但有的情况下ApiError和HttpError 不是一个真正的类，而只是Typescript的接口  
[demo07][demo07]  

此时就只能用类型断言 通过判断是否存在code属性 来判断传入的参数是不是ApiError  
[demo08][demo08]

### 3. 将任何一个类型断言为any

理想情况下。TypeScript 得类型系统运转良好 每个值得类型 都具体而准确。

但有时候，我们确定这段代码不会出错比如  
[demo09][demo09]

断言为any 是解决typescript中类型问题得最后一个手段
它极有可能掩盖了真正得类型错误，所以如果不是非常确定，就不要使用as any

一方面不能滥用as any 另一方面也不要完全否定它得作用，我们需要在类型的严格性和开发的便利性之间掌握平衡(这也是typescript 的设计理念之一)，才能发挥出typescript的最大价值

### 4. 将any 断言为一个具体的类型

[demo10][demo10]

我们在使用的时候，最好能够将调用它之后的返回值断言为一个精确的类型，这样就方便了后续的操作
[demo11][demo11]
上面的例子中我们调用完getCacheData之后，立即将他断言为Cat类型，这样的话明确了tom的类型，后续对tom的访问就有了代码补全，提高了代码的可维护性

### 5. 类型断言的限制
[demo12][demo12]

当Animal 兼容Cat时 我们就可以互相进行类型断言了  
[demo13][demo13]

* 允许animal as Cat 是因为 父类可以断言为子类 
* 允许cat as Animal 是因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性、调用父类的方法，就不会有问题 故 [子类可以被断言为父类]


综上所述

* 联合类型可以被断言为其中一个类型
* 父类可以被断言为子类
* 任何类型都可以被断言为any
* any可以被断言为任何类型
* 要是的A能够被断言为B，只需要A兼容B 或 B兼容A即可


## 双重断言
既然
* 任何类型都可以被断言为any
* any可以被断言为任何类型

那么我们可以使用双重断言 as any as Foo 来讲任何类型断言为任何另一个类型
[demo14][demo14]
在上面的例子中，若直接使用 cat as Fish 肯定会报错，因为 Cat 和 Fish 互相都不兼容

但是若使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。

若你使用了这种双重断言，那么十有八九是非常错误的，它很可能会导致运行时错误。

## 类型断言 vs 类型转换

类型断言只会影响TypeScript编译时的类型，类型断言语句在编译结果中会被删除

[demo15][demo15]

若要进行类型转换，需要直接调用类型转换的方法  
[demo16][demo16]

## 类型断言 vs 类型声明

[demo17][demo17]

我们使用 as Cat 将 any 类型断言为了 Cat 类型。

但实际上还有其他方式可以解决这个问题

[demo18][demo18]  

上面的例子中，我们通过类型声明的方式，将 tom 声明为 Cat，然后再将 any 类型的 getCacheData('tom') 赋值给 Cat 类型的 tom。

这和类型断言是非常相似的，而且产生的结果也几乎是一样的——tom 在接下来的代码中都变成了 Cat 类型。

区别  
[demo19][demo19]  
在上面的例子中，由于 Animal 兼容 Cat，故可以将 animal 断言为 Cat 赋值给 tom。

但是若直接声明 tom 为 Cat 类型：  

[demo20][demo20]

这很容易理解，Animal 可以看作是 Cat 的父类，当然不能将父类的实例赋值给类型为子类的变量。

深入的讲，它们的核心区别就在于：

animal 断言为 Cat，只需要满足 Animal 兼容 Cat 或 Cat 兼容 Animal 即可
animal 赋值给 tom，需要满足 Cat 兼容 Animal 才行
知道了它们的核心区别，就知道了类型声明是比类型断言更加严格的。

所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 as 语法更加优雅。

## 类型断言 vs 泛型


[demo01]: ./01.ts
[demo02]: ./02.ts
[demo03]: ./03.ts
[demo04]: ./04.ts
[demo05]: ./05.ts
[demo06]: ./06.ts
[demo07]: ./07.ts
[demo08]: ./08.ts
[demo09]: ./09.ts
[demo10]: ./10.ts
[demo11]: ./11.ts
[demo12]: ./12.ts
[demo13]: ./13.ts
[demo14]: ./14.ts
[demo15]: ./15.ts
[demo16]: ./16.ts
[demo17]: ./17.ts
[demo18]: ./18.ts
[demo19]: ./19.ts
[demo20]: ./20.ts